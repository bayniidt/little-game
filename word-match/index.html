<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å•è¯æ¶ˆæ¶ˆä¹ - Word Match</title>
  <style>
    :root {
      --primary-color: #4a90e2;
      --secondary-color: #f5a623;
      --bg-color: #f0f2f5;
      --card-bg: #ffffff;
      --text-color: #333;
      --matched-color: #7ed321;
    }

    #app {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100vw;
      height: 100dvh;
      /* Fill exactly the dynamic viewport height */
      padding: 10px;
      /* Reduce padding to save space */
      overflow: hidden;
      /* No scrolling on the main container */
    }

    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      min-height: -webkit-fill-available;
      /* Safari fix */
      -webkit-tap-highlight-color: transparent;
      overflow: hidden;
      /* Mobile default: prevent body scroll */
    }

    header {
      background-color: var(--primary-color);
      color: white;
      width: 100%;
      max-width: 600px;
      height: 42px;
      /* Fixed height */
      padding: 0 10px;
      /* Reduced padding */
      text-align: center;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 5px;
      flex-shrink: 0;
      /* é˜²æ­¢è¢«å‹ç¼© */
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    h1 {
      margin: 0;
      font-size: 1.2rem;
      /* Mobile friendly title size */
      flex: 1;
      text-align: center;
    }

    .icon-btn {
      background: none;
      border: none;
      color: white;
      padding: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.2s;
      box-shadow: none;
      width: 36px;
      height: 36px;
    }

    .icon-btn:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .game-info-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      /* Center items vertically */
      width: 100%;
      max-width: 500px;
      height: 55px;
      /* Fixed height */
      /* Constrain width on PC */
      margin: 5px 0;
      /* Reduced margin */
      font-size: 1rem;
      font-weight: bold;
      color: var(--text-color);
      background: white;
      padding: 0 12px;
      border-radius: 8px;
      box-sizing: border-box;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      flex-shrink: 0;
    }

    .info-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 50px;
    }

    .settings-btn {
      background: transparent;
      border: 1px solid #eee;
      color: #888;
      box-shadow: none;
      padding: 4px;
      border-radius: 4px;
      width: 32px;
      height: 32px;
      margin-left: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .settings-btn.active {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }

    .settings-group {
      display: flex;
      align-items: center;
    }

    .info-label {
      font-size: 0.8rem;
      color: #888;
      font-weight: normal;
    }

    .info-val {
      font-size: 1rem;
    }

    .game-container {
      width: 100%;
      display: grid;
      /* Initial default, will be overridden by JS */
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 8px;
      padding: 5px;
      box-sizing: border-box;
      margin-bottom: 10px;
      overflow: hidden;
      /* Absolutely no scrolling */
      flex: 1;
      /* Take all remaining space */
      min-height: 0;
      /* Critical for grid/flex nesting */
      min-width: 0;
      /* Add this to prevent potential overflow issues in grid items */
    }

    .card {
      background-color: var(--card-bg);
      border: 2px solid #e1e4e8;
      width: 100%;
      height: 100%;
      /* Fill the grid cell exactly */
      min-height: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
      user-select: none;
      text-align: center;
      padding: 4px;
      /* Reduced from 16px to save space */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }

    .card-content {
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      word-break: break-word;
      /* Soft wrap, don't break mid-word unless necessary */
      width: 100%;
      font-size: 0.9rem;
      /* Smaller font for mobile */
      line-height: 1.2;
    }

    .card:active {
      transform: scale(0.95);
    }

    .card.selected {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
    }

    .card.matched {
      background-color: var(--matched-color);
      border-color: var(--matched-color);
      color: white;
      opacity: 0;
      transform: scale(0.5);
      pointer-events: none;
    }

    .card.wrong {
      background-color: #ff6b6b;
      color: white;
      border-color: #ff6b6b;
      animation: shake 0.4s;
    }

    @keyframes shake {

      0%,
      100% {
        transform: translateX(0);
      }

      20% {
        transform: translateX(-6px);
      }

      40% {
        transform: translateX(6px);
      }

      60% {
        transform: translateX(-6px);
      }

      80% {
        transform: translateX(6px);
      }
    }

    .card img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      pointer-events: none;
      /* Let clicks pass through to card */
    }

    .controls {
      width: 100%;
      max-width: 600px;
      height: 150px;
      /* Fixed height */
      display: flex;
      flex-direction: column;
      justify-content: center;
      /* Center content vertically if possible, or usually justify-content: space-between might be better for controls */
      gap: 8px;
      flex-shrink: 0;
      padding-bottom: env(safe-area-inset-bottom);
      overflow-y: auto;
      /* Handle overflow if 150px is too tight on small screens */
    }

    .deck-selector {
      display: flex;
      gap: 8px;
      position: relative;
      /* ç¡®ä¿å­å…ƒç´ å®šä½ä¸Šä¸‹æ–‡æ­£ç¡® */
    }

    select {
      flex: 1;
      padding: 8px 12px;
      /* Less top/bottom padding */
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 1rem;
      background: white;
      /* å°è¯•ä¿®å¤å¯èƒ½çš„ç§»åŠ¨ç«¯ appearance é—®é¢˜ */
      -webkit-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 10px center;
      background-size: 1em;
      padding-right: 30px;
    }

    button {
      padding: 8px 16px;
      /* Less padding */
      font-size: 1rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      background-color: var(--primary-color);
      color: white;
      transition: opacity 0.2s;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    button:active {
      opacity: 0.8;
      transform: translateY(1px);
    }

    button.secondary {
      background-color: var(--secondary-color);
      color: #fff;
    }

    .upload-btn-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }

    .upload-btn-wrapper input[type=file] {
      font-size: 100px;
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      cursor: pointer;
      width: 100%;
      height: 100%;
    }

    /* å¼¹çª—æ ·å¼ */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(2px);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background: white;
      padding: 30px 20px;
      border-radius: 20px;
      text-align: center;
      width: 85%;
      max-width: 360px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      animation: popIn 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    }

    @keyframes popIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    #modal-title {
      margin-top: 0;
      color: var(--primary-color);
    }

    /* Loading Overlay */
    .loading-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.9);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      font-size: 1.1rem;
      color: var(--primary-color);
      font-weight: bold;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .tip-box {
      font-size: 0.75rem;
      /* Smaller tip text */
      color: #666;
      background: #f9f9f9;
      padding: 6px;
      /* Compact padding */
      border-radius: 8px;
      text-align: center;
      line-height: 1.4;
      border: 1px dashed #d1d5db;
    }

    .tip-box a {
      color: var(--primary-color);
      text-decoration: none;
      font-weight: bold;
      border-bottom: 1px solid currentColor;
    }

    /* Match Popup */
    #match-popup .modal-content {
      background: white;
      padding: 20px;
      width: 80%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      align-items: center;
    }

    .match-content-row {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    .match-content-row img {
      max-height: 150px;
      object-fit: contain;
      margin: 5px 0;
    }

    .match-text {
      font-weight: bold;
      color: var(--primary-color);
      word-break: break-word;
      line-height: 1.3;
    }

    /* Second row text styling (Definitions/Chinese) */
    #match-popup-p2 .match-text {
      color: #555;
      font-weight: normal;
      margin-top: 8px;
    }

    .match-subtext {
      font-size: 0.9rem;
      color: #666;
      word-break: break-word;
      margin-top: 5px;
    }

    /* PCç«¯ä¼˜åŒ–: æ›´å®½çš„å¸ƒå±€ï¼Œæ›´å¤šçš„åˆ— */
    @media (min-width: 768px) {
      body {
        height: auto;
        min-height: 100vh;
        overflow-y: auto;
        /* Allow full page scroll on PC */
      }

      header,
      .game-info-bar,
      .game-container,
      .controls {
        max-width: 550px;
      }

      .game-container {
        /* On PC, we let standard CSS take over or JS logic */
        gap: 15px;
      }


      .card {
        font-size: 1.1rem;
        border-width: 3px;
      }

      h1 {
        font-size: 2rem;
      }
    }
  </style>
</head>

<body>

  <div id="app">

    <header>
      <button class="icon-btn" onclick="location.href='../index.html'" aria-label="è¿”å›é¦–é¡µ">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
          <polyline points="9 22 9 12 15 12 15 22"></polyline>
        </svg>
      </button>
      <h1>å•è¯æ¶ˆæ¶ˆä¹</h1>
      <div style="width: 36px;"></div> <!-- Spacer for balance -->
    </header>

    <div class="game-info-bar">
      <div class="info-item">
        <span class="info-label">å‰©ä½™</span>
        <span class="info-val" id="stats-remain">0</span>
      </div>
      <div class="info-item">
        <span class="info-label">æ—¶é—´</span>
        <span class="info-val" id="timer">0s</span>
      </div>
      <div class="info-item">
        <span class="info-label">å¾—åˆ†</span>
        <span class="info-val" id="score">0</span>
      </div>

      <!-- Settings Toggles -->
      <div class="settings-group">
        <button id="btn-toggle-audio" class="settings-btn active" onclick="Game.toggleAudio()"
          aria-label="Toggle Audio">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
            <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
          </svg>
        </button>
        <button id="btn-toggle-popup" class="settings-btn active" onclick="Game.togglePopup()"
          aria-label="Toggle Popup">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
        </button>
      </div>
    </div>

    <div class="game-container" id="game-board">
      <!-- å¡ç‰‡å°†é€šè¿‡ JS ç”Ÿæˆ -->
    </div>

    <div class="controls">
      <div class="deck-selector">
        <div style="flex: 1;">
          <select id="preset-deck" style="
            overflow: hidden;
            width: 100%;
            text-overflow:ellipsis;
            white-space: nowrap;">
            <option value="default">é»˜è®¤è¯åº“ (å†…ç½®)</option>
            <!-- <option value="https://zhledufdwcprnqclbqbp.supabase.co/storage/v1/object/public/apkg/xgn1.apkg" selected>
              æ–°æ¦‚å¿µè‹±è¯­ 1</option>
            <option
              value="https://bayniidt.oss-cn-shenzhen.aliyuncs.com/%E6%96%B0%E6%A6%82%E5%BF%B5%E7%AC%AC%E4%BA%8C%E5%86%8C.apkg">
              æ–°æ¦‚å¿µè‹±è¯­ 2</option>
            <option
              value="https://bayniidt.oss-cn-shenzhen.aliyuncs.com/%E6%96%B0%E6%A6%82%E5%BF%B5%E7%AC%AC%E4%B8%89%E5%86%8C.apkg">
              æ–°æ¦‚å¿µè‹±è¯­ 3</option>
            <option
              value="https://bayniidt.oss-cn-shenzhen.aliyuncs.com/%E6%96%B0%E6%A6%82%E5%BF%B5%E7%AC%AC%E5%9B%9B%E5%86%8C.apkg">
              æ–°æ¦‚å¿µè‹±è¯­ 4</option>
            <option
              value="https://bayniidt.oss-cn-shenzhen.aliyuncs.com/4000_Essential_English_Words_all_books_en-en.apkg">
              4000å¸¸ç”¨è¯(å›¾ç‰‡)</option> -->
            <option
              value="https://59-47-239-233.pd1.cjjd19.com/1135-user-share-free-download-cdn.123295.com/123-887/514b4bcd/1854918904-0/514b4bcdd3db7e6437dc5f923526af77/c-m106?v=5&t=1766735275&r=MD83P8&bzc=2&bzs=313835343931383930343a34323837393136393a31333535323133313a313835343931383930343a32&ur=eigengpbgum&urn=0&s=1766735275233e06f5f3e207a9af56f7087bedb301&bzp=0&bi=2814336910&filename=xgn1.apkg&x-mf-biz-cid=a02b9fdc-0f5e-48df-908f-93ee83bd851c-c4937c&auto_redirect=0&ndcp=1&cache_type=1&xmfcid=fea36207-7b8a-41b9-9e00-9c245a4f00f06135e8d8a93"
              selected>
              æ–°æ¦‚å¿µè‹±è¯­ 1
            </option>
            <option
              value="https://59-47-237-131.pd1.cjjd19.com/1135-user-share-free-download-cdn.123295.com/123-790/57ab9449/1817689251-0/57ab94498ea59a864f5bbf37008ef316/c-m9001?v=5&t=1766735407&r=KL2CFG&bzc=2&bzs=313835343931383930343a34323837393137303a3133393838313939383a313835343931383930343a32&ur=eigengpbgum&urn=0&s=17667354074ea7ddd47fad1cd32e5f2e0d53803969&bzp=0&bi=2814336910&filename=xgn2.apkg&x-mf-biz-cid=7762ead2-9f94-4bc2-b7d0-0cbdf55b35b2-08139d&auto_redirect=0&ndcp=1&cache_type=1&xmfcid=a240ec14-3588-4f88-b950-8124f7dc2b9e4735e8d8a93">
              æ–°æ¦‚å¿µè‹±è¯­ 2
            </option>
            <option
              value="https://59-47-237-141.pd1.cjjd19.com/1135-user-share-free-download-cdn.123295.com/123-538/adf923c4/1816624159-0/adf923c4bf5a4be1b2f0410ff8ff0a1a/c-m9001?v=5&t=1766735461&r=1TAPTW&bzc=2&bzs=313835343931383930343a34323837393137313a3138393838323137323a313835343931383930343a32&ur=eigengpbgum&urn=0&s=1766735461592392089717fea77111adabb39f1229&bzp=0&bi=2814336910&filename=xgn3.apkg&x-mf-biz-cid=6b9c6407-8e16-4fd8-9230-14db684fd362-6eaa77&auto_redirect=0&ndcp=1&cache_type=1&xmfcid=f57a7ceb-c914-45d3-817f-77acb719932c4735e8d8a93">
              æ–°æ¦‚å¿µè‹±è¯­ 3
            </option>
            <option
              value="https://59-47-239-233.pd1.cjjd19.com/1135-user-share-free-download-cdn.123295.com/123-901/7e619053/1817689251-0/7e6190537e3eb251bc63e48792902b85/c-m9001?v=5&t=1766735539&r=X5O12Q&bzc=2&bzs=313835343931383930343a34323837393137323a3133303332393735343a313835343931383930343a32&ur=eigengpbgum&urn=0&s=17667355399cae43e2ad482dde98f392006552f677&bzp=0&bi=2814336910&filename=xgn4.apkg&x-mf-biz-cid=5fc796e5-c0d6-4162-a734-be4110a7fc9f-3dab77&auto_redirect=0&ndcp=1&cache_type=1&xmfcid=93696f19-dab9-47f4-a671-148b342a341a7035e8d8a93">
              æ–°æ¦‚å¿µè‹±è¯­ 4
            </option>
            <option
              value="https://59-47-239-233.pd1.cjjd19.com/1135-user-share-free-download-cdn.123295.com/123-793/35da7a6e/1830389115-0/35da7a6e48e70f2f8f4c260f35163319/c-m9005?v=5&t=1766735569&r=ERQYBK&bzc=2&bzs=313835343931383930343a34323837393137333a3232343539323131353a313835343931383930343a32&ur=eigengpbgum&urn=0&s=1766735569771dd57473f45f01d1ca45f31efabc8d&bzp=0&bi=2814336910&filename=4000word.apkg&x-mf-biz-cid=36255359-f21e-4e9f-a46b-cadd4686d864-584000&auto_redirect=0&ndcp=1&cache_type=1&xmfcid=a37d406e-7ce4-4d04-ab65-b537336714b77135e8d8a93">
              4000å¸¸ç”¨è¯(å›¾ç‰‡)
            </option>
          </select>
        </div>
        <div class="upload-btn-wrapper" style="width: 150px;">
          <button class="secondary" style="width: 100%; height: 100%; padding: 0 15px; white-space: nowrap;">ğŸ“
            æœ¬åœ°ä¸Šä¼ </button>
          <input type="file" id="file-upload" accept=".apkg">
        </div>
      </div>

      <div class="tip-box">
        ğŸ’¡ æç¤º: æƒ³è¦æ›´å¤šè¯åº“ï¼Ÿ<a href="https://ankiweb.net/shared/decks?search=%E6%96%B0%E6%A6%82%E5%BF%B5" target="_blank">ç‚¹æ­¤å»
          AnkiWeb ä¸‹è½½</a> .apkg æ–‡ä»¶<br>
        ä¸‹è½½åç‚¹å‡»ä¸Šæ–¹ "ğŸ“ æœ¬åœ°ä¸Šä¼ " å³å¯åŠ è½½æ¸¸ç©
      </div>

      <button onclick="Game.init(true)" style="width: 100%">ğŸ”„ é‡ç½®æ¸¸æˆ</button>
    </div>

  </div>


  <!-- ç»“ç®—å¼¹çª— -->
  <div id="modal" class="modal">
    <div class="modal-content">
      <h2 id="modal-title">ğŸ‘ æŒ‘æˆ˜æˆåŠŸ!</h2>
      <p id="modal-msg" style="font-size: 1.1rem; margin: 20px 0; line-height: 1.6;">ç”¨æ—¶: 30s</p>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <button id="restart-btn" class="secondary"
          onclick="Game.init(true); document.getElementById('modal').style.display='none'">é‡æ–°å¼€å§‹</button>
        <button id="next-level-btn"
          onclick="Game.nextLevel(); document.getElementById('modal').style.display='none'">ä¸‹ä¸€ç»„</button>
      </div>
    </div>
  </div>

  <!-- Match Popup -->
  <div id="match-popup" class="modal" style="z-index: 1500;">
    <div class="modal-content" style="position: relative; padding-top: 25px;">
      <button class="icon-btn"
        style="position: absolute; top: 8px; right: 8px; color: #aaa; width: 24px; height: 24px; background: transparent;"
        onclick="Game.closeMatchPopup()">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
      <div id="match-popup-p1" class="match-content-row"></div>
      <div style="width: 100%; height: 1px; background: #eee;"></div>
      <div id="match-popup-p2" class="match-content-row"></div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loading-overlay" class="loading-overlay">
    <div class="spinner"></div>
    <p>æ­£åœ¨åŠ è½½è¯åº“...</p>
  </div>

  <!-- å¼•å…¥è§£æåº“ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>

  <script>
    // Anki åª’ä½“èµ„æºç®¡ç†å™¨
    const AnkiMedia = {
      zip: null,
      map: {},
      init(zip, mediaJson) {
        this.zip = zip
        this.map = {}
        // mediaJson: { "0": "file.mp3" } -> map: { "file.mp3": "0" }
        for (const [key, val] of Object.entries(mediaJson)) {
          this.map[val] = key
        }
      },
      async getUrl(filename) {
        if (!this.zip || !this.map[filename]) return null
        const zipId = this.map[filename]
        const file = this.zip.file(zipId)
        if (!file) return null
        const blob = await file.async('blob')
        // Revoke old? simplified for now
        return URL.createObjectURL(blob)
      },
      // Alias for compatibility
      async getAudio(filename) { return this.getUrl(filename) },

      async getAudioData(filename) {
        if (!this.zip || !this.map[filename]) return null
        const zipId = this.map[filename]
        const file = this.zip.file(zipId)
        if (!file) return null
        return await file.async('arraybuffer')
      },

      async loadImage(imgEl, filename) {
        const url = await this.getUrl(filename)
        if (url) imgEl.src = url
      }
    }

    // éŸ³æ•ˆç®¡ç†å™¨ (Web Audio API)
    const Sound = {
      ctx: null,
      init() {
        if (!this.ctx) {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)()
        }
        if (this.ctx.state === 'suspended') {
          this.ctx.resume()
        }
      },
      playTone(freq, type, duration, startTime = 0) {
        if (!this.ctx) this.init()
        const osc = this.ctx.createOscillator()
        const gain = this.ctx.createGain()
        osc.type = type
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime)

        // åŒ…ç»œ
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime + startTime)
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + startTime + duration)

        osc.connect(gain)
        gain.connect(this.ctx.destination)
        osc.start(this.ctx.currentTime + startTime)
        osc.stop(this.ctx.currentTime + startTime + duration)
      },
      playMatch() {
        // å®ï¼(é«˜éŸ³)
        this.playTone(880, 'sine', 0.1)
        this.playTone(1760, 'sine', 0.3, 0.1)
      },
      playWrong() {
        // å—¡... (ä½éŸ³é”¯é½¿æ³¢)
        this.playTone(150, 'sawtooth', 0.4)
      },
      playWin() {
        // èƒœåˆ©éŸ³æ•ˆ
        const notes = [523.25, 659.25, 783.99, 1046.50] // C E G C
        notes.forEach((freq, i) => {
          this.playTone(freq, 'triangle', 0.3, i * 0.15)
        })
      },
      async playAudioData(arrayBuffer) {
        if (!this.ctx) this.init()
        // Force resume (critical for mobile/Chrome autoplay policy)
        if (this.ctx.state === 'suspended') {
          try { await this.ctx.resume() } catch (e) { console.warn(e) }
        }

        return new Promise(async (resolve) => {
          if (!arrayBuffer || arrayBuffer.byteLength === 0) {
            console.log("Audio: Empty buffer")
            resolve()
            return
          }
          try {
            console.log("Audio: Decoding...")
            // Must slice because decode detaches
            const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer.slice(0))
            const source = this.ctx.createBufferSource()
            source.buffer = audioBuffer
            source.connect(this.ctx.destination)

            // Simple robust completion
            let finished = false
            const onFinish = () => {
              if (!finished) {
                finished = true
                console.log("Audio: Finished")
                resolve()
              }
            }

            source.onended = onFinish
            source.start(0)
            console.log("Audio: Started, duration:", audioBuffer.duration)

            // Backup timeout (duration + 1s to be safe)
            setTimeout(onFinish, (audioBuffer.duration * 1000) + 1000)

          } catch (e) {
            console.warn("Web Audio play failed", e)
            resolve()
          }
        })
      }
    }

    // é»˜è®¤è¯åº“
    const DEFAULT_LIBRARY = [
      { en: 'Apple', zh: 'è‹¹æœ' }, { en: 'Banana', zh: 'é¦™è•‰' }, { en: 'Cat', zh: 'çŒ«' },
      { en: 'Dog', zh: 'ç‹—' }, { en: 'Elephant', zh: 'å¤§è±¡' }, { en: 'Flower', zh: 'èŠ±æœµ' },
      { en: 'Guitar', zh: 'å‰ä»–' }, { en: 'House', zh: 'æˆ¿å­' }, { en: 'Ice cream', zh: 'å†°æ·‡æ·‹' },
      { en: 'Jacket', zh: 'å¤¹å…‹' }, { en: 'Kite', zh: 'é£ç­' }
    ]

    // å½“å‰ä½¿ç”¨è¯åº“
    let WORD_LIBRARY = [...DEFAULT_LIBRARY]
    let customLibrary = []
    let customDeckName = ""

    const SAVE_KEY = 'word_match_save_v2'

    const Game = {
      matchesFound: 0,
      matchesTotal: 0,
      score: 0,
      timer: 0,
      timerInterval: null,
      firstCard: null,
      isLocked: false,

      workingDeck: [],
      currentCards: [], // å½“å‰æ˜¾ç¤ºçš„å¡ç‰‡æ•°æ®
      batchSize: 6,

      // Popup control
      popupResolver: null,
      popupTimer: null,


      // Settings
      settings: {
        playAudio: true,
        showPopup: true
      },

      init(fullReset = false) {
        // é¦–æ¬¡äº¤äº’åˆå§‹åŒ–éŸ³é¢‘ç¯å¢ƒ
        Sound.init()
        this.resetState()
        this.loadSettings()

        if (fullReset || this.workingDeck.length === 0) {
          this.workingDeck = [...WORD_LIBRARY].sort(() => 0.5 - Math.random())
          if (fullReset) this.score = 0

          // --- Adapt Batch Size for Long Content ---
          // Peek at next 6 items to see if they are huge
          // Heuristic: check avg length of first 5 items
          let charCount = 0
          for (let i = 0;i < Math.min(5, this.workingDeck.length);i++) {
            const item = this.workingDeck[i]
            charCount += (item.en?.length || 0) + (item.zh?.length || 0)
          }
          const avgLen = charCount / 5
          // If average length > 25 (e.g. phrases/sentences), reduce batch to 4 (8 cards) -> 2 columns
          if (avgLen > 25) {
            this.batchSize = 4
          } else {
            this.batchSize = 6
          }

          // æ–°å¼€å±€ï¼Œå–ä¸€æ‰¹æ–°å¡
          const currentBatch = this.workingDeck.splice(0, this.batchSize)
          if (currentBatch.length === 0) {
            alert("æ­å–œï¼ä½ å·²ç»å®Œæˆäº†æ‰€æœ‰å•è¯ï¼")
            this.init(true)
            return
          }
          this.matchesTotal = currentBatch.length
          this.currentCards = this.generateCards(currentBatch)
        } else {
          // ä¸‹ä¸€å…³
          // Check avg length again for next batch
          // We need 'peek' logic or just grabbing and checking
          let charCount = 0
          const peekSize = Math.min(5, this.workingDeck.length)
          for (let i = 0;i < peekSize;i++) {
            const item = this.workingDeck[i]
            charCount += (item.en?.length || 0) + (item.zh?.length || 0)
          }
          const avgLen = peekSize > 0 ? charCount / peekSize : 0
          if (avgLen > 25) {
            this.batchSize = 4
          } else {
            this.batchSize = 6
          }

          const currentBatch = this.workingDeck.splice(0, this.batchSize)
          this.matchesTotal = currentBatch.length
          this.currentCards = this.generateCards(currentBatch)
        }

        this.renderBoard(this.currentCards)
        this.updateStats()
        this.startTimer()
        this.save() // ä¿å­˜åˆå§‹çŠ¶æ€
      },

      // ä»å­˜æ¡£æ¢å¤
      restore(state) {
        Sound.init()
        this.resetState()

        this.score = state.score
        this.timer = state.timer
        this.workingDeck = state.workingDeck
        this.currentCards = state.currentCards
        this.matchesFound = state.matchesFound
        this.matchesTotal = state.matchesTotal

        this.renderBoard(this.currentCards)
        this.updateStats()
        this.startTimer()
      },

      save() {
        const deckVal = document.getElementById('preset-deck').value
        // Don't save full library if it's default or online (save space)
        const shouldSaveLib = deckVal !== 'default' && !deckVal.startsWith('http')

        const state = {
          score: this.score,
          timer: this.timer,
          workingDeck: this.workingDeck,
          currentCards: this.currentCards,
          matchesFound: this.matchesFound,
          matchesTotal: this.matchesTotal,
          wordLibrary: shouldSaveLib ? WORD_LIBRARY : null,
          deckValue: deckVal,
          customDeckName: deckVal === 'custom' ? customDeckName : null,
          timestamp: Date.now()
        }
        try {
          localStorage.setItem(SAVE_KEY, JSON.stringify(state))
        } catch (e) {
          console.warn("Save failed", e)
        }
      },

      resetState() {
        this.matchesFound = 0
        this.timer = 0
        this.firstCard = null
        this.isLocked = false
        this.updateStats()
        clearInterval(this.timerInterval)
        document.getElementById('modal').style.display = 'none'
      },

      updateStats() {
        document.getElementById('score').innerText = this.score
        document.getElementById('timer').innerText = `${this.timer}s`
        // æ˜¾ç¤ºå‰©ä½™ / æ€»æ•°
        const remaining = this.workingDeck.length + (this.matchesTotal - this.matchesFound)
        document.getElementById('stats-remain').innerText = `${remaining} / ${WORD_LIBRARY.length}`
      },

      generateCards(words) {
        let cards = []
        words.forEach((word, index) => {
          cards.push({ id: index, content: word.en, type: 'en', matched: false, audio: word.audio })
          cards.push({ id: index, content: word.zh, type: 'zh', matched: false, audio: word.audio })
        })
        return cards.sort(() => 0.5 - Math.random())
      },

      renderBoard(cards) {
        const board = document.getElementById('game-board')
        board.innerHTML = ''

        // --- Smart Grid Calculation ---
        // Goal: Maximize card dimensions within the container without scrolling (overflow:hidden)
        // We have 12 cards total (matchesTotal * 2)
        // Candidates: 3 cols x 4 rows (3x4) OR 4 cols x 3 rows (4x3)

        const rect = board.getBoundingClientRect()
        const W = rect.width
        const H = rect.height
        const gap = 10 // approximate gap

        // Option A: 3 cols x 4 rows
        const w3 = (W - 2 * gap) / 3
        const h4 = (H - 3 * gap) / 4
        const minDimA = Math.min(w3, h4) // constrained dimension of the card

        // Option B: 4 cols x 3 rows
        const w4 = (W - 3 * gap) / 4
        const h3 = (H - 2 * gap) / 3
        const minDimB = Math.min(w4, h3) // constrained dimension of the card

        // Strategy: Choose the option that yields the LARGER constrained dimension
        // This effectively picks the layout where cards are "bigger" or "less squashed"

        // Dynamic Force: If we have 8 cards (4 pairs), we prefer 2x4 for text width
        const count = cards.length

        if (count <= 8) {
          // 2 columns x 4 rows
          board.style.gridTemplateColumns = 'repeat(2, 1fr)'
          board.style.gridTemplateRows = `repeat(${Math.ceil(count / 2)}, 1fr)`
        } else {
          // Standard choice logic
          if (minDimB > minDimA) {
            // Option B (4x3) is better
            board.style.gridTemplateColumns = 'repeat(4, 1fr)'
            board.style.gridTemplateRows = 'repeat(3, 1fr)'
          } else {
            // Option A (3x4) is better (default for portrait)
            board.style.gridTemplateColumns = 'repeat(3, 1fr)'
            board.style.gridTemplateRows = 'repeat(4, 1fr)'
          }
        }

        cards.forEach(cardData => {
          const card = document.createElement('div')
          card.className = 'card'
          if (cardData.matched) {
            card.classList.add('matched')
          }
          // Use inner container for text truncation
          card.innerHTML = `<div class="card-content">${cardData.content}</div>`
          card.dataset.id = cardData.id

          // Process Images
          const imgs = card.querySelectorAll('img')
          imgs.forEach(img => {
            const src = img.getAttribute('src')
            if (src && !src.startsWith('data:') && !src.startsWith('http')) {
              AnkiMedia.loadImage(img, src)
            }
          })

          // ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼Œéœ€æ³¨æ„é—­åŒ…å¼•ç”¨
          card.addEventListener('click', () => this.handleCardClick(card, cardData))
          board.appendChild(card)
        })
      },

      handleCardClick(card, cardData) {
        if (this.isLocked) return
        if (card.classList.contains('matched')) return
        if (card === this.firstCard) return // ç‚¹å‡»è‡ªå·±

        // æ’­æ”¾è½»å¾®ç‚¹å‡»å£°(å¯é€‰)ï¼Œè¿™é‡Œæš‚ä¸åŠ ï¼Œä¿æŒç®€æ´
        card.classList.add('selected')

        if (!this.firstCard) {
          this.firstCard = card
        } else {
          this.checkForMatch(this.firstCard, card)
        }
      },

      checkForMatch(card1, card2) {
        this.isLocked = true
        const isMatch = card1.dataset.id === card2.dataset.id
        if (isMatch) {
          this.handleMatch(card1, card2)
        } else {
          this.handleMismatch(card1, card2)
        }
      },

      async handleMatch(card1, card2) {
        // æ’­æ”¾æ­£ç¡®éŸ³æ•ˆ
        Sound.playMatch()

        // è·å–æ•°æ®
        const id = card1.dataset.id
        const pair = this.currentCards.filter(c => String(c.id) === String(id))

        let audioBuffer = null
        // Check both for audio (some decks have it on Back)
        const audioFile = pair[0].audio || pair[1].audio

        if (audioFile) {
          console.log("Found audio file:", audioFile)
          audioBuffer = await AnkiMedia.getAudioData(audioFile)
        }

        // Display Modal or just Play Sound
        try {
          if (this.settings.showPopup) {
            // Explicit Sort: Find the card with type='en' for TOP
            let p1 = pair.find(c => c.type === 'en')
            let p2 = pair.find(c => c.type === 'zh')
            if (!p1) p1 = pair[0]
            if (!p2) p2 = (p1 === pair[0]) ? pair[1] : pair[0]

            // Pass audioBuffer only if settings allow audio
            const bufferToPlay = this.settings.playAudio ? audioBuffer : null
            await this.showMatchPopup(p1.content, p2.content, bufferToPlay)

          } else {
            // Popup OFF: Play audio in background if settings allow
            if (this.settings.playAudio && audioBuffer) {
              Sound.playAudioData(audioBuffer)
            }
            // Slight delay for visual match feedback
            await new Promise(r => setTimeout(r, 300))
          }
        } catch (e) {
          console.error(e)
        }

        // Update Model
        this.currentCards.forEach(c => {
          if (String(c.id) === String(id)) {
            c.matched = true
          }
        })

        card1.classList.remove('selected')
        card2.classList.remove('selected')
        card1.classList.add('matched')
        card2.classList.add('matched')

        this.score += 10
        this.matchesFound++
        this.firstCard = null
        this.isLocked = false
        this.updateStats()
        this.save()

        if (this.matchesFound === this.matchesTotal) {
          this.gameOver()
        }
      },

      async showMatchPopup(content1, content2, audioBuffer) {
        const popup = document.getElementById('match-popup')
        const p1 = document.getElementById('match-popup-p1')
        const p2 = document.getElementById('match-popup-p2')

        // æ¸²æŸ“å†…å®¹è¾…åŠ©å‡½æ•°
        const render = (el, content) => {
          el.innerHTML = `<div class="match-text">${content}</div>`
          const imgs = el.querySelectorAll('img')
          imgs.forEach(img => {
            img.removeAttribute('class')
            img.style.maxWidth = '100%'
            img.style.height = 'auto'
            const src = img.getAttribute('src')
            if (src && !src.startsWith('data:') && !src.startsWith('http')) {
              AnkiMedia.loadImage(img, src)
            }
          })
        }

        render(p1, content1) // Top (English)
        render(p2, content2) // Bottom (Chinese)

        popup.style.display = 'flex'

        // Create a Promise that resolves when closed
        return new Promise(resolve => {
          this.popupResolver = resolve

          // Auto close logic
          if (audioBuffer) {
            // Play audio
            Sound.playAudioData(audioBuffer).then(() => {
              // Audio finished (or timed out inside playAudioData)
              // Add a small delay for better UX
              this.popupTimer = setTimeout(() => {
                this.closeMatchPopup()
              }, 500)
            })
          } else {
            // No audio, default timeout
            this.popupTimer = setTimeout(() => {
              this.closeMatchPopup()
            }, 1500)
          }
        })
      },

      closeMatchPopup() {
        const popup = document.getElementById('match-popup')
        popup.style.display = 'none'

        // Clear any pending timers
        if (this.popupTimer) {
          clearTimeout(this.popupTimer)
          this.popupTimer = null
        }

        // Resolve the promise to let game continue
        if (this.popupResolver) {
          this.popupResolver()
          this.popupResolver = null
        }
      },

      handleMismatch(card1, card2) {
        // æ’­æ”¾é”™è¯¯éŸ³æ•ˆ
        Sound.playWrong()

        card1.classList.add('wrong')
        card2.classList.add('wrong')
        setTimeout(() => {
          card1.classList.remove('selected', 'wrong')
          card2.classList.remove('selected', 'wrong')
          this.score = Math.max(0, this.score - 1)
          this.firstCard = null
          this.isLocked = false
          this.updateStats()
        }, 800)
      },

      startTimer() {
        if (this.timerInterval) clearInterval(this.timerInterval)
        this.timerInterval = setInterval(() => {
          this.timer++
          this.updateStats()
          // Optimize: don't save every second, maybe only special events or throttle?
          // For now, let's just save on match/level change to save IO.
          // If we want exact second resume, we need to save here, but it's expensive.
          // Let's settle for saving every 5 seconds?
          if (this.timer % 5 === 0) this.save()
        }, 1000)
      },

      // --- Toggle Logic ---
      toggleAudio() {
        this.settings.playAudio = !this.settings.playAudio
        this.updateSettingsUI()
        this.saveSettings()
      },

      togglePopup() {
        this.settings.showPopup = !this.settings.showPopup
        this.updateSettingsUI()
        this.saveSettings()
      },

      updateSettingsUI() {
        const btnAudio = document.getElementById('btn-toggle-audio')
        const btnPopup = document.getElementById('btn-toggle-popup')

        if (this.settings.playAudio) {
          btnAudio.classList.add('active')
          btnAudio.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`
        } else {
          btnAudio.classList.remove('active')
          btnAudio.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`
        }

        if (this.settings.showPopup) {
          btnPopup.classList.add('active')
          btnPopup.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>`
        } else {
          btnPopup.classList.remove('active')
          btnPopup.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>`
        }
      },

      saveSettings() {
        localStorage.setItem('wm_settings', JSON.stringify(this.settings))
      },

      loadSettings() {
        try {
          const raw = localStorage.getItem('wm_settings')
          if (raw) {
            this.settings = JSON.parse(raw)
          }
        } catch (e) { }
        this.updateSettingsUI()
      },

      gameOver() {
        clearInterval(this.timerInterval)
        this.save() // Save final state of level (though it's cleared)
        Sound.playWin() // æ’­æ”¾èƒœåˆ©éŸ³æ•ˆ

        const modal = document.getElementById('modal')
        const title = document.getElementById('modal-title')
        const msg = document.getElementById('modal-msg')
        const nextBtn = document.getElementById('next-level-btn')
        const restartBtn = document.getElementById('restart-btn')

        title.innerText = "ğŸ‘ æœ¬ç»„æŒ‘æˆ˜æˆåŠŸ!"
        msg.innerText = `å¾—åˆ†: ${this.score}\nè€—æ—¶: ${this.timer}ç§’`

        if (this.workingDeck.length > 0) {
          nextBtn.style.display = 'block'
          restartBtn.innerText = "é‡ç½®è¿›åº¦"
          msg.innerHTML += `<br><span style="color:#666; font-size:0.9rem">è¿˜æœ‰ ${this.workingDeck.length} ä¸ªå•è¯å¾…æŒ‘æˆ˜</span>`
        } else {
          nextBtn.style.display = 'none'
          restartBtn.innerText = "é‡æ–°å¼€å§‹"
          title.innerText = "ğŸ† å…¨éƒ¨é€šå…³!"
          msg.innerText = `æœ€ç»ˆæ€»åˆ†: ${this.score}`
        }

        modal.style.display = 'flex'
      },

      nextLevel() {
        this.init(false)
      },
    }

    // --- Anki è§£æé€»è¾‘ (å°è£…) ---
    async function loadAnkiFile(fileOrUrl, isUrl = false, silent = false) {
      const loading = document.getElementById('loading-overlay')
      if (!silent) loading.style.display = 'flex'

      try {
        let data
        if (isUrl) {
          // å¦‚æœæ˜¯ defaultï¼Œç›´æ¥æ¢å¤
          if (fileOrUrl === 'default') {
            WORD_LIBRARY = [...DEFAULT_LIBRARY]
            if (!silent) Game.init(true)
            if (!silent) loading.style.display = 'none'
            return
          }
          // Fetch loading
          const response = await fetch(fileOrUrl)
          if (!response.ok) throw new Error(`æ— æ³•åŠ è½½æ–‡ä»¶: ${response.statusText}`)
          data = await response.arrayBuffer()
        } else {
          // File object loading
          if (fileOrUrl instanceof Blob) {
            data = await fileOrUrl.arrayBuffer()
          } else {
            data = fileOrUrl
          }
        }

        const zip = await JSZip.loadAsync(data)

        // åˆå§‹åŒ–åª’ä½“æ˜ å°„
        try {
          const mediaFile = zip.file("media")
          if (mediaFile) {
            const mediaJson = JSON.parse(await mediaFile.async("string"))
            AnkiMedia.init(zip, mediaJson)
          }
        } catch (e) {
          console.warn("Media parsing failed", e)
        }

        // æŸ¥æ‰¾æ•°æ®åº“
        let dbFile = zip.file('collection.anki2')
        if (!dbFile) dbFile = zip.file('collection.anki21')

        if (!dbFile) {
          alert('æ— æ³•è§£æ Anki æ–‡ä»¶ï¼šæœªæ‰¾åˆ° collection.anki2 æ•°æ®åº“')
          loading.style.display = 'none'
          return
        }

        const dbData = await dbFile.async('uint8array')
        const SQL = await initSqlJs({
          locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
        })

        const db = new SQL.Database(dbData)
        const res = db.exec("SELECT flds FROM notes")
        console.log("'ğŸ‘Š ~ res'", res)

        let newLibrary = []
        if (res.length > 0 && res[0].values.length > 0) {
          // æ£€æŸ¥ç‰ˆæœ¬è­¦å‘Š
          const firstFld = res[0].values[0][0]
          if (firstFld.includes("Please update to the latest Anki version")) {
            // å°è¯•å†æ¬¡æŸ¥æ‰¾ .anki21 å¦‚æœæˆ‘ä»¬ä¹‹å‰æ²¡æ‰¾è¿‡
            const dbFileV21 = zip.file('collection.anki21')
            if (dbFileV21) {
              const dbDataV21 = await dbFileV21.async('uint8array')
              db.close()
              const db2 = new SQL.Database(dbDataV21)
              const res2 = db2.exec("SELECT flds FROM notes")
              console.log("'ğŸ‘Š ~ res2'", res2)
              if (res2.length > 0) parseRows(res2[0].values, newLibrary)
              db2.close()
            } else {
              alert("æ–°ç‰ˆ Anki æ ¼å¼ä¸”æ‰¾ä¸åˆ° .anki21 æ–‡ä»¶ï¼Œè¯·å¯¼å‡ºå…¼å®¹ç‰ˆã€‚")
            }
          } else {
            parseRows(res[0].values, newLibrary)
          }
        }
        db.close()

        if (newLibrary.length > 5) {
          WORD_LIBRARY = newLibrary
          // ä¿å­˜åˆ° LocalStorage æ–¹ä¾¿ä¸‹æ¬¡ç›´æ¥ç”¨? æš‚æ—¶ä¸å­˜é˜²æ­¢å¤ªå¤§
          // alert(`åŠ è½½æˆåŠŸï¼åŒ…å« ${newLibrary.length} ä¸ªå•è¯ã€‚`) // remove annoying alert on auto-load
          if (!silent) Game.init(true)
        } else {
          alert('æœªæ‰¾åˆ°æœ‰æ•ˆå•è¯ï¼Œå·²æ¢å¤é»˜è®¤è¯åº“ã€‚')
          WORD_LIBRARY = [...DEFAULT_LIBRARY]
          if (!silent) Game.init(true)
        }

      } catch (err) {
        console.error(err)

        // å¦‚æœæ˜¯ Fetch é”™è¯¯ (é€šå¸¸æ˜¯æœ¬åœ°è¿è¡Œæ²¡èµ·æœåŠ¡å¯¼è‡´ CORS æˆ–æ–‡ä»¶ä¸å­˜åœ¨)
        // æˆ–è€…æ˜¯å…¶ä»–è§£æé”™è¯¯ï¼Œä¸ºäº†é˜²æ­¢é¡µé¢å¡æ­»ï¼Œé™çº§åˆ°é»˜è®¤è¯åº“
        if (err.message.includes('fetch') || err.message.includes('Failed to fetch')) {
          console.warn("è‡ªåŠ¨åŠ è½½æ–‡ä»¶å¤±è´¥ (å¯èƒ½æ˜¯ CORS é™åˆ¶æˆ–æ–‡ä»¶ä¸å­˜åœ¨), å·²å›é€€åˆ°é»˜è®¤è¯åº“ã€‚")
        } else {
          if (!silent) alert('åŠ è½½å¤±è´¥: ' + err.message)
        }

        // æ¢å¤é»˜è®¤
        if (!silent) {
          document.getElementById('preset-deck').value = 'default' // å¦‚æœæ²¡æœ‰ default é€‰é¡¹å¯èƒ½ä¼šç©º
          WORD_LIBRARY = [...DEFAULT_LIBRARY]
          Game.init(true)
        }
      } finally {
        if (!silent) loading.style.display = 'none'
      }
    }

    function parseRows(rows, targetArray) {
      // Helper: Check if text is just an ID 
      const isId = (str) => {
        if (!str) return true
        const s = str.trim()
        if (s.length === 0) return true
        // 2_1, 101, 2-1. Usually short.
        if (s.length > 10) return false
        // Must contain a digit to be an ID? Usually yes for these decks.
        // "excuse" has no digits. "2_1" does.
        if (!/\d/.test(s)) return false
        // Allow digits, underscores, dashes, dots, spaces
        if (/^[\d_\-\.\s]+$/.test(s)) return true
        return false
      }

      rows.forEach(row => {
        const fields = row[0].split('\x1f')
        if (fields.length >= 2) {
          let audio = null
          let imgField = null
          // Store text candidates with their original index or just strings
          let textFields = []

          fields.forEach((f, idx) => {
            // Audio
            const m = f.match(/\[sound:([^\]]+)\]/)
            if (m && !audio) audio = m[1]

            // Image (Grab the whole tag)
            if (f.includes('<img')) {
              const tmp = document.createElement("DIV")
              tmp.innerHTML = f
              const img = tmp.querySelector('img')
              if (img && !imgField) {
                imgField = img.outerHTML
              }
            }

            // Text Cleaning
            let clean = f.replace(/\[sound:[^\]]+\]/g, "") // remove sound
            // Strip HTML tags including IMG (we handled img separately)
            const tmp = document.createElement("DIV")
            tmp.innerHTML = clean
            let text = (tmp.textContent || tmp.innerText || "").trim()

            if (text.length > 0) {
              textFields.push(text)
            }
          })

          let front = ""
          let back = ""

          if (imgField) {
            // --- IMAGE MODE ---
            // Front is Image
            front = imgField

            // Back is the first "meaningful" text field
            // Iterate textFields, ignoring IDs
            for (const t of textFields) {
              if (!isId(t)) {
                back = t
                break
              }
            }
            // Fallback: if no text found (rare), or all were IDs
            if (!back && textFields.length > 0) back = textFields[0]

          } else {
            // --- TEXT MODE ---
            // Filter "ID-only" fields first (to clean up V2-like artifacts if they lacked images)
            const valid = textFields.filter(t => !isId(t))

            if (valid.length > 0) {
              front = valid[0]
              // Default Logic: Index 2 (Def) > Index 1 (Pho) 
              if (valid.length >= 3) {
                back = valid[2]
              } else if (valid.length >= 2) {
                back = valid[1]
              }
            }
          }

          if (front && back && !front.includes("Please update")) {
            targetArray.push({ en: front, zh: back, audio: audio })
          }
        }
      })
    }

    // --- äº‹ä»¶ç›‘å¬ ---
    document.getElementById('file-upload').addEventListener('change', async (e) => {
      const file = e.target.files[0]
      if (file) {
        // å…ˆåœ¨ UI ä¸Šå ä½ï¼Œè¿™æ · loadAnkiFile é‡Œçš„ Game.init è°ƒç”¨çš„ save() å°±èƒ½è¯»åˆ°æ­£ç¡®çš„ value
        const sel = document.getElementById('preset-deck')
        let opt = sel.querySelector('option[value="custom"]')
        if (!opt) {
          opt = document.createElement('option')
          opt.value = "custom"
          sel.appendChild(opt)
        }
        customDeckName = file.name
        opt.innerText = `ğŸ“‚ ${customDeckName}`
        sel.value = "custom"

        await loadAnkiFile(file)

        // å¦‚æœåŠ è½½æˆåŠŸï¼ˆæ²¡è¢«é‡ç½®å› defaultï¼‰ï¼Œç¼“å­˜èµ·æ¥
        if (sel.value === 'custom') {
          customLibrary = [...WORD_LIBRARY]
          // å†æ¬¡ä¿å­˜ä»¥ç¡®ä¿ metadata å®Œæ•´
          Game.save()
        }
      }
    })

    document.getElementById('preset-deck').addEventListener('change', (e) => {
      const val = e.target.value
      if (val === 'custom') {
        if (customLibrary.length > 0) {
          WORD_LIBRARY = [...customLibrary]
          Game.init(true)
        } else {
          // å¼‚å¸¸æƒ…å†µï¼Œç†è®ºä¸Šé€‰ä¸åˆ°
          alert("è¯·é‡æ–°ä¸Šä¼ æ–‡ä»¶")
        }
      } else {
        loadAnkiFile(val, true)
      }
    })

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        Game.save()
      }
    })

    // å¯åŠ¨æ¸¸æˆ
    // é€»è¾‘ï¼šå°è¯•åŠ è½½å­˜æ¡£ -> å¤±è´¥åˆ™è‡ªåŠ¨åŠ è½½é»˜è®¤/é€‰å®šè¯åº“
    function tryLoadInfo() {
      try {
        const raw = localStorage.getItem(SAVE_KEY)
        if (raw) {
          const state = JSON.parse(raw)
          // ç®€å•çš„æ ¡éªŒ
          if (state && state.currentCards && state.currentCards.length > 0) {
            console.log("Found save, restoring...")
            // Restore library if saved, otherwise we might need to fetch it (if online)
            // For now, if it's online/default, we can reload it in background or just proceed with current level
            if (state.wordLibrary) {
              WORD_LIBRARY = state.wordLibrary
            } else {
              if (state.deckValue === 'default') {
                WORD_LIBRARY = [...DEFAULT_LIBRARY]
              } else if (state.deckValue && state.deckValue.startsWith('http')) {
                // Trigger background load for next levels
                loadAnkiFile(state.deckValue, true, true) // Add silent mode arg
              }
            }

            if (state.deckValue) {
              const sel = document.getElementById('preset-deck')
              // å¦‚æœæ˜¯ customï¼Œæ¢å¤é€‰é¡¹
              if (state.deckValue === 'custom' && state.wordLibrary) {
                let opt = sel.querySelector('option[value="custom"]')
                if (!opt) {
                  opt = document.createElement('option')
                  opt.value = "custom"
                  sel.appendChild(opt)
                }
                customDeckName = state.customDeckName || "å·²åŠ è½½æ–‡ä»¶"
                opt.innerText = `ğŸ“‚ ${customDeckName}`

                customLibrary = state.wordLibrary
              }
              if (sel) sel.value = state.deckValue
            }
            Game.restore(state)
            return true
          }
        }
      } catch (e) {
        console.error("Load save error", e)
      }
      return false
    }

    if (!tryLoadInfo()) {
      const startDeck = document.getElementById('preset-deck').value
      if (startDeck && startDeck !== 'default') {
        loadAnkiFile(startDeck, true)
      } else {
        Game.init(true)
      }
    }

  </script>
</body>

</html>
