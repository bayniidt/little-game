<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å•è¯æ¶ˆæ¶ˆä¹ - Word Match</title>
  <style>
    :root {
      --primary-color: #4a90e2;
      --secondary-color: #f5a623;
      --bg-color: #f0f2f5;
      --card-bg: #ffffff;
      --text-color: #333;
      --matched-color: #7ed321;
    }

    #app {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      padding: 16px;
      overflow: hidden;
    }

    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      min-height: -webkit-fill-available;
      /* Safari fix */
      -webkit-tap-highlight-color: transparent;
      overflow: hidden;
      /* Mobile default: prevent body scroll */
    }

    header {
      background-color: var(--primary-color);
      color: white;
      width: 100%;
      max-width: 600px;
      padding: 0.8rem;
      text-align: center;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 5px;
      flex-shrink: 0;
      /* é˜²æ­¢è¢«å‹ç¼© */
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    h1 {
      margin: 0;
      font-size: 1.2rem;
      /* Mobile friendly title size */
      flex: 1;
      text-align: center;
    }

    .icon-btn {
      background: none;
      border: none;
      color: white;
      padding: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.2s;
      box-shadow: none;
      width: 36px;
      height: 36px;
    }

    .icon-btn:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .game-info-bar {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 500px;
      /* Constrain width on PC */
      margin: 10px 0;
      font-size: 1rem;
      font-weight: bold;
      color: var(--text-color);
      background: white;
      padding: 8px 12px;
      border-radius: 8px;
      box-sizing: border-box;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      flex-shrink: 0;
    }

    .info-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .info-label {
      font-size: 0.8rem;
      color: #888;
      font-weight: normal;
    }

    .info-val {
      font-size: 1rem;
    }

    .game-container {
      width: 100%;
      /* max-width controlled by media query */
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(4, 1fr);
      /* 3x4 = 12 cards fixed */
      gap: 10px;
      /* Slightly larger gap */
      padding: 5px;
      box-sizing: border-box;
      margin-bottom: 10px;
      overflow: hidden;
      /* No scrollbars on mobile */
      flex: 1;
      min-height: 0;
      align-content: stretch;
      justify-items: stretch;
    }

    .card {
      background-color: var(--card-bg);
      border: 2px solid #e1e4e8;
      /* Remove fixed aspect ratio, let grid define shape to fit container */
      /* aspect-ratio: 1; */
      height: 100%;
      min-height: 80px;
      /* User requested min-height */
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 1rem;
      /* Larger font for mobile */
      transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
      user-select: none;
      text-align: center;
      padding: 4px;
      /* word-wrap handled by inner content now */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      overflow: hidden;
      /* Prevent expansion */
    }

    .card-content {
      display: -webkit-box;
      -webkit-line-clamp: 4;
      /* Limit to 4 lines */
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      word-break: break-all;
      width: 100%;
    }

    .card:active {
      transform: scale(0.95);
    }

    .card.selected {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
    }

    .card.matched {
      background-color: var(--matched-color);
      border-color: var(--matched-color);
      color: white;
      opacity: 0;
      transform: scale(0.5);
      pointer-events: none;
    }

    .card.wrong {
      background-color: #ff6b6b;
      color: white;
      border-color: #ff6b6b;
      animation: shake 0.4s;
    }

    @keyframes shake {

      0%,
      100% {
        transform: translateX(0);
      }

      20% {
        transform: translateX(-6px);
      }

      40% {
        transform: translateX(6px);
      }

      60% {
        transform: translateX(-6px);
      }

      80% {
        transform: translateX(6px);
      }
    }

    .controls {
      width: 100%;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex-shrink: 0;
      min-height: 250px;
      padding-bottom: env(safe-area-inset-bottom);
      /* é€‚é…å…¨é¢å±åº•éƒ¨ */
    }

    .deck-selector {
      display: flex;
      gap: 8px;
      position: relative;
      /* ç¡®ä¿å­å…ƒç´ å®šä½ä¸Šä¸‹æ–‡æ­£ç¡® */
    }

    select {
      flex: 1;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 1rem;
      background: white;
      /* å°è¯•ä¿®å¤å¯èƒ½çš„ç§»åŠ¨ç«¯ appearance é—®é¢˜ */
      -webkit-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 10px center;
      background-size: 1em;
      padding-right: 30px;
    }

    button {
      padding: 12px 24px;
      font-size: 1rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      background-color: var(--primary-color);
      color: white;
      transition: opacity 0.2s;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    button:active {
      opacity: 0.8;
      transform: translateY(1px);
    }

    button.secondary {
      background-color: var(--secondary-color);
      color: #fff;
    }

    .upload-btn-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }

    .upload-btn-wrapper input[type=file] {
      font-size: 100px;
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      cursor: pointer;
      width: 100%;
      height: 100%;
    }

    /* å¼¹çª—æ ·å¼ */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(2px);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background: white;
      padding: 30px 20px;
      border-radius: 20px;
      text-align: center;
      width: 85%;
      max-width: 360px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      animation: popIn 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    }

    @keyframes popIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    #modal-title {
      margin-top: 0;
      color: var(--primary-color);
    }

    /* Loading Overlay */
    .loading-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.9);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      font-size: 1.1rem;
      color: var(--primary-color);
      font-weight: bold;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .tip-box {
      font-size: 0.8rem;
      color: #666;
      background: #f9f9f9;
      padding: 10px;
      border-radius: 8px;
      text-align: center;
      line-height: 1.5;
      border: 1px dashed #d1d5db;
    }

    .tip-box a {
      color: var(--primary-color);
      text-decoration: none;
      font-weight: bold;
      border-bottom: 1px solid currentColor;
    }

    /* PCç«¯ä¼˜åŒ–: æ›´å®½çš„å¸ƒå±€ï¼Œæ›´å¤šçš„åˆ— */
    @media (min-width: 768px) {
      body {
        height: auto;
        min-height: 100vh;
        overflow-y: auto;
        /* Allow full page scroll on PC */
      }

      header,
      .game-info-bar,
      .game-container,
      .controls {
        max-width: 550px;
      }

      .game-container {
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        /* 4x3 = 12 cards on PC */
        gap: 15px;
        overflow: visible;
        /* Remove inner scrollbar on PC */
        height: auto;
        flex: none;
        /* Allow it to grow */
      }

      .card {
        font-size: 1.1rem;
        border-width: 3px;
      }

      h1 {
        font-size: 2rem;
      }
    }
  </style>
</head>

<body>

  <div id="app">

    <header>
      <button class="icon-btn" onclick="location.href='../index.html'" aria-label="è¿”å›é¦–é¡µ">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
          <polyline points="9 22 9 12 15 12 15 22"></polyline>
        </svg>
      </button>
      <h1>å•è¯æ¶ˆæ¶ˆä¹</h1>
      <div style="width: 36px;"></div> <!-- Spacer for balance -->
    </header>

    <div class="game-info-bar">
      <div class="info-item">
        <span class="info-label">å‰©ä½™</span>
        <span class="info-val" id="stats-remain">0</span>
      </div>
      <div class="info-item">
        <span class="info-label">æ—¶é—´</span>
        <span class="info-val" id="timer">0s</span>
      </div>
      <div class="info-item">
        <span class="info-label">å¾—åˆ†</span>
        <span class="info-val" id="score">0</span>
      </div>
    </div>

    <div class="game-container" id="game-board">
      <!-- å¡ç‰‡å°†é€šè¿‡ JS ç”Ÿæˆ -->
    </div>

    <div class="controls">
      <div class="deck-selector">
        <select id="preset-deck">
          <option value="default">é»˜è®¤è¯åº“ (å†…ç½®)</option>
          <option value="https://zhledufdwcprnqclbqbp.supabase.co/storage/v1/object/public/apkg/xgn1.apkg" selected>
            æ–°æ¦‚å¿µè‹±è¯­1
            (åœ¨çº¿)</option>
        </select>
        <div class="upload-btn-wrapper">
          <button class="secondary" style="width: 100%; height: 100%; padding: 0 15px; white-space: nowrap;">ğŸ“
            æœ¬åœ°ä¸Šä¼ </button>
          <input type="file" id="file-upload" accept=".apkg">
        </div>
      </div>

      <div class="tip-box">
        ğŸ’¡ æç¤º: æƒ³è¦æ›´å¤šè¯åº“ï¼Ÿ<a href="https://ankiweb.net/shared/decks?search=%E6%96%B0%E6%A6%82%E5%BF%B5" target="_blank">ç‚¹æ­¤å»
          AnkiWeb ä¸‹è½½</a> .apkg æ–‡ä»¶<br>
        ä¸‹è½½åç‚¹å‡»ä¸Šæ–¹ "ğŸ“ æœ¬åœ°ä¸Šä¼ " å³å¯åŠ è½½æ¸¸ç©
      </div>

      <button onclick="Game.init(true)" style="width: 100%">ğŸ”„ é‡ç½®æ¸¸æˆ</button>
    </div>

  </div>


  <!-- ç»“ç®—å¼¹çª— -->
  <div id="modal" class="modal">
    <div class="modal-content">
      <h2 id="modal-title">ğŸ‘ æŒ‘æˆ˜æˆåŠŸ!</h2>
      <p id="modal-msg" style="font-size: 1.1rem; margin: 20px 0; line-height: 1.6;">ç”¨æ—¶: 30s</p>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <button id="restart-btn" class="secondary"
          onclick="Game.init(true); document.getElementById('modal').style.display='none'">é‡æ–°å¼€å§‹</button>
        <button id="next-level-btn"
          onclick="Game.nextLevel(); document.getElementById('modal').style.display='none'">ä¸‹ä¸€ç»„</button>
      </div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loading-overlay" class="loading-overlay">
    <div class="spinner"></div>
    <p>æ­£åœ¨åŠ è½½è¯åº“...</p>
  </div>

  <!-- å¼•å…¥è§£æåº“ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>

  <script>
    // éŸ³æ•ˆç®¡ç†å™¨ (Web Audio API)
    const Sound = {
      ctx: null,
      init() {
        if (!this.ctx) {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)()
        }
        if (this.ctx.state === 'suspended') {
          this.ctx.resume()
        }
      },
      playTone(freq, type, duration, startTime = 0) {
        if (!this.ctx) this.init()
        const osc = this.ctx.createOscillator()
        const gain = this.ctx.createGain()
        osc.type = type
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime)

        // åŒ…ç»œ
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime + startTime)
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + startTime + duration)

        osc.connect(gain)
        gain.connect(this.ctx.destination)
        osc.start(this.ctx.currentTime + startTime)
        osc.stop(this.ctx.currentTime + startTime + duration)
      },
      playMatch() {
        // å®ï¼(é«˜éŸ³)
        this.playTone(880, 'sine', 0.1)
        this.playTone(1760, 'sine', 0.3, 0.1)
      },
      playWrong() {
        // å—¡... (ä½éŸ³é”¯é½¿æ³¢)
        this.playTone(150, 'sawtooth', 0.4)
      },
      playWin() {
        // èƒœåˆ©éŸ³æ•ˆ
        const notes = [523.25, 659.25, 783.99, 1046.50] // C E G C
        notes.forEach((freq, i) => {
          this.playTone(freq, 'triangle', 0.3, i * 0.15)
        })
      }
    }

    // é»˜è®¤è¯åº“
    const DEFAULT_LIBRARY = [
      { en: 'Apple', zh: 'è‹¹æœ' }, { en: 'Banana', zh: 'é¦™è•‰' }, { en: 'Cat', zh: 'çŒ«' },
      { en: 'Dog', zh: 'ç‹—' }, { en: 'Elephant', zh: 'å¤§è±¡' }, { en: 'Flower', zh: 'èŠ±æœµ' },
      { en: 'Guitar', zh: 'å‰ä»–' }, { en: 'House', zh: 'æˆ¿å­' }, { en: 'Ice cream', zh: 'å†°æ·‡æ·‹' },
      { en: 'Jacket', zh: 'å¤¹å…‹' }, { en: 'Kite', zh: 'é£ç­' }
    ]

    // å½“å‰ä½¿ç”¨è¯åº“
    let WORD_LIBRARY = [...DEFAULT_LIBRARY]

    const SAVE_KEY = 'word_match_save_v1';

    const Game = {
      matchesFound: 0,
      matchesTotal: 0,
      score: 0,
      timer: 0,
      timerInterval: null,
      firstCard: null,
      isLocked: false,

      workingDeck: [],
      currentCards: [], // å½“å‰æ˜¾ç¤ºçš„å¡ç‰‡æ•°æ®
      batchSize: 6,

      init(fullReset = false) {
        // é¦–æ¬¡äº¤äº’åˆå§‹åŒ–éŸ³é¢‘ç¯å¢ƒ
        Sound.init()
        this.resetState()

        if (fullReset || this.workingDeck.length === 0) {
          this.workingDeck = [...WORD_LIBRARY].sort(() => 0.5 - Math.random())
          if (fullReset) this.score = 0
          
          // æ–°å¼€å±€ï¼Œå–ä¸€æ‰¹æ–°å¡
          const currentBatch = this.workingDeck.splice(0, this.batchSize)
          if (currentBatch.length === 0) {
            alert("æ­å–œï¼ä½ å·²ç»å®Œæˆäº†æ‰€æœ‰å•è¯ï¼")
            this.init(true)
            return
          }
          this.matchesTotal = currentBatch.length
          this.currentCards = this.generateCards(currentBatch)
        } else {
             // è¿™ç§æƒ…å†µé€šå¸¸æ˜¯ init(false) å³ä¸‹ä¸€å…³ï¼Œå·²ç»åœ¨ gameOver é‡Œåˆ¤æ–­äº† workingDeck é•¿åº¦
             // å¦‚æœæ˜¯ä» load() æ¢å¤çš„ï¼Œä¸ä¼šè¿›è¿™é‡Œï¼Œå› ä¸ºä¼šç›´æ¥æ¸²æŸ“
             const currentBatch = this.workingDeck.splice(0, this.batchSize)
             this.matchesTotal = currentBatch.length
             this.currentCards = this.generateCards(currentBatch)
        }

        this.renderBoard(this.currentCards)
        this.updateStats()
        this.startTimer()
        this.save() // ä¿å­˜åˆå§‹çŠ¶æ€
      },

      // ä»å­˜æ¡£æ¢å¤
      restore(state) {
        Sound.init()
        this.resetState()
        
        this.score = state.score
        this.timer = state.timer
        this.workingDeck = state.workingDeck
        this.currentCards = state.currentCards
        this.matchesFound = state.matchesFound
        this.matchesTotal = state.matchesTotal
        
        this.renderBoard(this.currentCards)
        this.updateStats()
        this.startTimer()
      },

      save() {
          const deckVal = document.getElementById('preset-deck').value;
          // Don't save full library if it's default or online (save space)
          const shouldSaveLib = deckVal !== 'default' && !deckVal.startsWith('http');
          
          const state = {
              score: this.score,
              timer: this.timer,
              workingDeck: this.workingDeck,
              currentCards: this.currentCards,
              matchesFound: this.matchesFound,
              matchesTotal: this.matchesTotal,
              wordLibrary: shouldSaveLib ? WORD_LIBRARY : null,
              deckValue: deckVal,
              timestamp: Date.now()
          };
          try {
              localStorage.setItem(SAVE_KEY, JSON.stringify(state));
          } catch(e) {
              console.warn("Save failed", e);
          }
      },

      resetState() {
        this.matchesFound = 0
        this.timer = 0
        this.firstCard = null
        this.isLocked = false
        this.updateStats()
        clearInterval(this.timerInterval)
        document.getElementById('modal').style.display = 'none'
      },

      updateStats() {
        document.getElementById('score').innerText = this.score
        document.getElementById('timer').innerText = `${this.timer}s`
        // æ˜¾ç¤ºå‰©ä½™ / æ€»æ•°
        const remaining = this.workingDeck.length + (this.matchesTotal - this.matchesFound)
        document.getElementById('stats-remain').innerText = `${remaining} / ${WORD_LIBRARY.length}`
      },

      generateCards(words) {
        let cards = []
        words.forEach((word, index) => {
          cards.push({ id: index, content: word.en, type: 'en', matched: false })
          cards.push({ id: index, content: word.zh, type: 'zh', matched: false })
        })
        return cards.sort(() => 0.5 - Math.random())
      },

      renderBoard(cards) {
        const board = document.getElementById('game-board')
        board.innerHTML = ''
        // CSS handles grid columns now (3 for mobile, 4 for PC)

        cards.forEach(cardData => {
          const card = document.createElement('div')
          card.className = 'card'
          if (cardData.matched) {
              card.classList.add('matched')
          }
          // Use inner container for text truncation
          card.innerHTML = `<div class="card-content">${cardData.content}</div>`
          card.dataset.id = cardData.id
          // ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼Œéœ€æ³¨æ„é—­åŒ…å¼•ç”¨
          card.addEventListener('click', () => this.handleCardClick(card, cardData))
          board.appendChild(card)
        })
      },

      handleCardClick(card, cardData) {
        if (this.isLocked) return
        if (card.classList.contains('matched')) return
        if (card === this.firstCard) return // ç‚¹å‡»è‡ªå·±

        // æ’­æ”¾è½»å¾®ç‚¹å‡»å£°(å¯é€‰)ï¼Œè¿™é‡Œæš‚ä¸åŠ ï¼Œä¿æŒç®€æ´
        card.classList.add('selected')

        if (!this.firstCard) {
          this.firstCard = card
        } else {
          this.checkForMatch(this.firstCard, card)
        }
      },

      checkForMatch(card1, card2) {
        this.isLocked = true
        const isMatch = card1.dataset.id === card2.dataset.id
        if (isMatch) {
          this.handleMatch(card1, card2)
        } else {
          this.handleMismatch(card1, card2)
        }
      },

      handleMatch(card1, card2) {
        // æ’­æ”¾æ­£ç¡®éŸ³æ•ˆ
        Sound.playMatch()

        // Update data model
        const id = card1.dataset.id
        this.currentCards.forEach(c => {
            if (String(c.id) === String(id)) {
                c.matched = true
            }
        })

        setTimeout(() => {
          card1.classList.remove('selected')
          card2.classList.remove('selected')
          card1.classList.add('matched')
          card2.classList.add('matched')

          this.score += 10
          this.matchesFound++
          this.firstCard = null
          this.isLocked = false
          this.updateStats()
          this.save() // ä¿å­˜è¿›åº¦

          if (this.matchesFound === this.matchesTotal) {
            this.gameOver()
          }
        }, 300)
      },

      handleMismatch(card1, card2) {
        // æ’­æ”¾é”™è¯¯éŸ³æ•ˆ
        Sound.playWrong()

        card1.classList.add('wrong')
        card2.classList.add('wrong')
        setTimeout(() => {
          card1.classList.remove('selected', 'wrong')
          card2.classList.remove('selected', 'wrong')
          this.score = Math.max(0, this.score - 1)
          this.firstCard = null
          this.isLocked = false
          this.updateStats()
        }, 800)
      },

      startTimer() {
        if(this.timerInterval) clearInterval(this.timerInterval);
        this.timerInterval = setInterval(() => {
          this.timer++
          this.updateStats()
          // Optimize: don't save every second, maybe only special events or throttle?
          // For now, let's just save on match/level change to save IO.
          // If we want exact second resume, we need to save here, but it's expensive.
          // Let's settle for saving every 5 seconds?
          if (this.timer % 5 === 0) this.save()
        }, 1000)
      },

      gameOver() {
        clearInterval(this.timerInterval)
        this.save() // Save final state of level (though it's cleared)
        Sound.playWin() // æ’­æ”¾èƒœåˆ©éŸ³æ•ˆ

        const modal = document.getElementById('modal')
        const title = document.getElementById('modal-title')
        const msg = document.getElementById('modal-msg')
        const nextBtn = document.getElementById('next-level-btn')
        const restartBtn = document.getElementById('restart-btn')

        title.innerText = "ğŸ‘ æœ¬ç»„æŒ‘æˆ˜æˆåŠŸ!"
        msg.innerText = `å¾—åˆ†: ${this.score}\nè€—æ—¶: ${this.timer}ç§’`

        if (this.workingDeck.length > 0) {
          nextBtn.style.display = 'block'
          restartBtn.innerText = "é‡ç½®è¿›åº¦"
          msg.innerHTML += `<br><span style="color:#666; font-size:0.9rem">è¿˜æœ‰ ${this.workingDeck.length} ä¸ªå•è¯å¾…æŒ‘æˆ˜</span>`
        } else {
          nextBtn.style.display = 'none'
          restartBtn.innerText = "é‡æ–°å¼€å§‹"
          title.innerText = "ğŸ† å…¨éƒ¨é€šå…³!"
          msg.innerText = `æœ€ç»ˆæ€»åˆ†: ${this.score}`
        }

        modal.style.display = 'flex'
      },

      nextLevel() {
        this.init(false)
      },
    }

    // --- Anki è§£æé€»è¾‘ (å°è£…) ---
    async function loadAnkiFile(fileOrUrl, isUrl = false, silent = false) {
      const loading = document.getElementById('loading-overlay')
      if (!silent) loading.style.display = 'flex'

      try {
        let data
        if (isUrl) {
          // å¦‚æœæ˜¯ defaultï¼Œç›´æ¥æ¢å¤
          if (fileOrUrl === 'default') {
            WORD_LIBRARY = [...DEFAULT_LIBRARY]
            if (!silent) Game.init(true)
            if (!silent) loading.style.display = 'none'
            return
          }
          // Fetch loading
          const response = await fetch(fileOrUrl)
          if (!response.ok) throw new Error(`æ— æ³•åŠ è½½æ–‡ä»¶: ${response.statusText}`)
          data = await response.arrayBuffer()
        } else {
          // File object loading
          data = fileOrUrl // Assume file object is compatible with JSZip load
        }

        const zip = await JSZip.loadAsync(data)

        // æŸ¥æ‰¾æ•°æ®åº“
        let dbFile = zip.file('collection.anki2')
        if (!dbFile) dbFile = zip.file('collection.anki21')

        if (!dbFile) {
          alert('æ— æ³•è§£æ Anki æ–‡ä»¶ï¼šæœªæ‰¾åˆ° collection.anki2 æ•°æ®åº“')
          loading.style.display = 'none'
          return
        }

        const dbData = await dbFile.async('uint8array')
        const SQL = await initSqlJs({
          locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
        })

        const db = new SQL.Database(dbData)
        const res = db.exec("SELECT flds FROM notes")

        let newLibrary = []
        if (res.length > 0 && res[0].values.length > 0) {
          // æ£€æŸ¥ç‰ˆæœ¬è­¦å‘Š
          const firstFld = res[0].values[0][0]
          if (firstFld.includes("Please update to the latest Anki version")) {
            // å°è¯•å†æ¬¡æŸ¥æ‰¾ .anki21 å¦‚æœæˆ‘ä»¬ä¹‹å‰æ²¡æ‰¾è¿‡
            const dbFileV21 = zip.file('collection.anki21')
            if (dbFileV21) {
              const dbDataV21 = await dbFileV21.async('uint8array')
              db.close()
              const db2 = new SQL.Database(dbDataV21)
              const res2 = db2.exec("SELECT flds FROM notes")
              if (res2.length > 0) parseRows(res2[0].values, newLibrary)
              db2.close()
            } else {
              alert("æ–°ç‰ˆ Anki æ ¼å¼ä¸”æ‰¾ä¸åˆ° .anki21 æ–‡ä»¶ï¼Œè¯·å¯¼å‡ºå…¼å®¹ç‰ˆã€‚")
            }
          } else {
            parseRows(res[0].values, newLibrary)
          }
        }
        db.close()

        if (newLibrary.length > 5) {
          WORD_LIBRARY = newLibrary
          // ä¿å­˜åˆ° LocalStorage æ–¹ä¾¿ä¸‹æ¬¡ç›´æ¥ç”¨? æš‚æ—¶ä¸å­˜é˜²æ­¢å¤ªå¤§
          // alert(`åŠ è½½æˆåŠŸï¼åŒ…å« ${newLibrary.length} ä¸ªå•è¯ã€‚`) // remove annoying alert on auto-load
          if (!silent) Game.init(true)
        } else {
          alert('æœªæ‰¾åˆ°æœ‰æ•ˆå•è¯ï¼Œå·²æ¢å¤é»˜è®¤è¯åº“ã€‚')
          WORD_LIBRARY = [...DEFAULT_LIBRARY]
          if (!silent) Game.init(true)
        }

      } catch (err) {
        console.error(err)

        // å¦‚æœæ˜¯ Fetch é”™è¯¯ (é€šå¸¸æ˜¯æœ¬åœ°è¿è¡Œæ²¡èµ·æœåŠ¡å¯¼è‡´ CORS æˆ–æ–‡ä»¶ä¸å­˜åœ¨)
        // æˆ–è€…æ˜¯å…¶ä»–è§£æé”™è¯¯ï¼Œä¸ºäº†é˜²æ­¢é¡µé¢å¡æ­»ï¼Œé™çº§åˆ°é»˜è®¤è¯åº“
        if (err.message.includes('fetch') || err.message.includes('Failed to fetch')) {
          console.warn("è‡ªåŠ¨åŠ è½½æ–‡ä»¶å¤±è´¥ (å¯èƒ½æ˜¯ CORS é™åˆ¶æˆ–æ–‡ä»¶ä¸å­˜åœ¨), å·²å›é€€åˆ°é»˜è®¤è¯åº“ã€‚")
        } else {
          if (!silent) alert('åŠ è½½å¤±è´¥: ' + err.message)
        }

        // æ¢å¤é»˜è®¤
        if (!silent) {
            document.getElementById('preset-deck').value = 'default' // å¦‚æœæ²¡æœ‰ default é€‰é¡¹å¯èƒ½ä¼šç©º
            WORD_LIBRARY = [...DEFAULT_LIBRARY]
            Game.init(true)
        }
      } finally {
        if (!silent) loading.style.display = 'none'
      }
    }

    function parseRows(rows, targetArray) {
      rows.forEach(row => {
        const fields = row[0].split('\x1f')
        if (fields.length >= 2) {
          const stripHtml = (html) => {
            const tmp = document.createElement("DIV")
            tmp.innerHTML = html
            return tmp.textContent || tmp.innerText || ""
          }
          const front = stripHtml(fields[0]).trim()
          const backRaw = (fields.length >= 3 && fields[2].trim()) ? fields[2] : fields[1]
          const back = stripHtml(backRaw).trim()

          if (front && back && front.length < 80 && back.length < 80 && !front.includes("Please update")) {
            targetArray.push({ en: front, zh: back })
          }
        }
      })
    }

    // --- äº‹ä»¶ç›‘å¬ ---
    document.getElementById('file-upload').addEventListener('change', (e) => {
      const file = e.target.files[0]
      if (file) loadAnkiFile(file)
    })

    document.getElementById('preset-deck').addEventListener('change', (e) => {
      const val = e.target.value
      loadAnkiFile(val, true)
    })

    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
            Game.save();
        }
    });
    
    // å¯åŠ¨æ¸¸æˆ
    // é€»è¾‘ï¼šå°è¯•åŠ è½½å­˜æ¡£ -> å¤±è´¥åˆ™è‡ªåŠ¨åŠ è½½é»˜è®¤/é€‰å®šè¯åº“
    function tryLoadInfo() {
      try {
        const raw = localStorage.getItem(SAVE_KEY);
        if (raw) {
          const state = JSON.parse(raw);
          // ç®€å•çš„æ ¡éªŒ
          if (state && state.currentCards && state.currentCards.length > 0) {
             console.log("Found save, restoring...");
             // Restore library if saved, otherwise we might need to fetch it (if online)
             // For now, if it's online/default, we can reload it in background or just proceed with current level
             if (state.wordLibrary) {
                 WORD_LIBRARY = state.wordLibrary;
             } else {
                 if (state.deckValue === 'default') {
                     WORD_LIBRARY = [...DEFAULT_LIBRARY];
                 } else if (state.deckValue && state.deckValue.startsWith('http')) {
                     // Trigger background load for next levels
                     loadAnkiFile(state.deckValue, true, true); // Add silent mode arg
                 }
             }

             if (state.deckValue) {
                const sel = document.getElementById('preset-deck');
                if (sel) sel.value = state.deckValue;
             }
             Game.restore(state);
             return true;
          }
        }
      } catch (e) {
        console.error("Load save error", e);
      }
      return false;
    }

    if (!tryLoadInfo()) {
       const startDeck = document.getElementById('preset-deck').value
       if (startDeck && startDeck !== 'default') {
         loadAnkiFile(startDeck, true)
       } else {
         Game.init(true)
       }
    }

  </script>
</body>

</html>
