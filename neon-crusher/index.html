<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- å…³é”®ï¼šç¦æ­¢ç¼©æ”¾ï¼Œé€‚é…ç§»åŠ¨ç«¯è§†å£ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ— é™å…­è¾¹å½¢ç²‰ç¢æœº</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: #050505;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, sans-serif;
            color: white;
            /* ç§»åŠ¨ç«¯å…¨å±å›ºå®šï¼Œé˜²æ­¢å›å¼¹æ•ˆæœ */
            position: fixed; 
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: none; /* ç¦æ­¢é»˜è®¤è§¦æ§è¡Œä¸º */
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            /* ç¡®ä¿ canvas å¡«æ»¡å®¹å™¨ä½†ä¸æº¢å‡º */
            width: 100%;
            height: 100%;
            border-radius: 0; /* ç§»åŠ¨ç«¯å…¨å±ä¸éœ€è¦åœ†è§’ */
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 5;
        }

        #score-board {
            position: absolute; top: 10%; /* ç¨å¾®å¾€ä¸‹æŒªä¸€ç‚¹ï¼Œé¿å¼€åˆ˜æµ·å± */
            font-size: 24px; font-weight: bold; letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            opacity: 0.9;
        }

        /* è¦†ç›–å±‚ */
        #overlay {
            background: rgba(0,0,0,0.85);
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 20; backdrop-filter: blur(5px);
            padding: 20px; text-align: center;
        }

        h1 { 
            font-size: 3rem; margin-bottom: 10px; 
            background: linear-gradient(to right, #00d2d3, #ff9f43); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; 
            text-transform: uppercase; font-style: italic;
        }
        p { color: #ccc; margin-bottom: 40px; font-size: 1.1rem; }

        #start-btn {
            padding: 15px 40px; font-size: 1.4rem; border: none; border-radius: 50px;
            background: white; color: black; font-weight: 800; cursor: pointer;
            box-shadow: 0 0 20px rgba(255,255,255,0.4); 
            transition: transform 0.1s;
        }
        #start-btn:active { transform: scale(0.95); }

        /* åº•éƒ¨æ§åˆ¶æ  - ç§»åŠ¨ç«¯æ”¹ä¸ºä¸¤è¡Œæˆ–ç¼©å°é—´è· */
        .controls {
            position: absolute; bottom: 30px; pointer-events: auto;
            display: flex; gap: 10px; z-index: 10;
            flex-wrap: wrap; justify-content: center; width: 95%;
        }
        .ctrl-btn {
            padding: 10px 16px; background: rgba(30, 30, 30, 0.9); 
            border: 1px solid #555; color: #eee; border-radius: 8px; 
            font-size: 13px; cursor: pointer; transition: 0.2s;
            flex-shrink: 0; /* é˜²æ­¢æŒ‰é’®è¢«æŒ¤å‹ */
        }
        .ctrl-btn:active { background: #555; }

        /* è§„åˆ™å¼¹çª— */
        #rules-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #1a1a1a; border: 2px solid #333; padding: 25px;
            border-radius: 15px; width: 85%; max-width: 400px;
            z-index: 30; display: none; box-shadow: 0 20px 50px rgba(0,0,0,0.9);
        }
        #rules-modal h2 { margin-bottom: 15px; color: #00d2d3; font-size: 1.5rem;}
        #rules-modal ul { text-align: left; margin-bottom: 20px; padding-left: 20px; line-height: 1.5; color: #ccc; font-size: 0.95rem; }
        #rules-modal .close-btn {
            background: #ff6b6b; color: white; border: none; padding: 10px 25px;
            border-radius: 8px; cursor: pointer; font-weight: bold; float: right;
            font-size: 1rem;
        }

        /* ç§»åŠ¨ç«¯ä¸“å±åª’ä½“æŸ¥è¯¢ */
        @media (max-width: 600px) {
            h1 { font-size: 2.2rem; }
            #score-board { font-size: 18px; top: 12%; }
            #start-btn { padding: 12px 30px; font-size: 1.2rem; }
            .controls { bottom: 20px; gap: 8px; }
            .ctrl-btn { padding: 8px 12px; font-size: 12px; }
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="score-board">BALLS: <span id="ball-count" style="color:#00d2d3">1</span> | KILLS: <span id="kill-count" style="color:#ff6b6b">0</span></div>
    </div>

    <div id="overlay">
        <h1>Neon Crusher</h1>
        <p>æ— é™åˆ†è£‚ Â· æŒ‡æ•°çˆ†ç‚¸ Â· è§£å‹ç¥å™¨</p>
        <button id="start-btn">å¯åŠ¨å¼•æ“</button>
    </div>

    <div id="rules-modal">
        <h2>æ¸¸æˆè§„åˆ™</h2>
        <ul>
            <li>ğŸ”´ <strong>ç›®æ ‡ï¼š</strong> å°çƒä¼šè‡ªåŠ¨æ”»å‡»å…­è¾¹å½¢ã€‚</li>
            <li>âš¡ <strong>åˆ†è£‚ï¼š</strong> å‡»ç¢æ–¹å—ï¼Œå°çƒ<strong>åˆ†è£‚ x2</strong>ã€‚</li>
            <li>ğŸ“ˆ <strong>æˆé•¿ï¼š</strong> æ•Œäººå˜å¼ºï¼Œå¼¹å¹•å˜å¤šã€‚</li>
            <li>â˜• <strong>æç¤ºï¼š</strong> æ”¾ç½®ç±»æ¸¸æˆï¼Œç›¯ç€çœ‹å°±è¡Œã€‚</li>
        </ul>
        <button class="close-btn" onclick="toggleRules()">å…³é—­</button>
    </div>

    <div class="controls">
        <button class="ctrl-btn" onclick="toggleRules()">ğŸ“œ è§„åˆ™</button>
        <button class="ctrl-btn" onclick="resetGame()">ğŸ”„ é‡ç½®</button>
        <button class="ctrl-btn" onclick="toggleMute()" id="mute-btn">ğŸ”Š éŸ³æ•ˆ: å¼€</button>
        <button class="ctrl-btn" onclick="location.href='../index.html'">ğŸ  é¦–é¡µ</button>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // ä¼˜åŒ–: å…³é—­é€æ˜é€šé“æå‡æ€§èƒ½

    // --- ç§»åŠ¨ç«¯æ£€æµ‹ä¸é…ç½® ---
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    const config = {
        spawnRate: 60,    
        // ç§»åŠ¨ç«¯é™ä½æœ€å¤§çƒæ•°ï¼Œé˜²æ­¢è¿‡çƒ­å¡é¡¿
        maxBalls: isMobile ? 150 : 500, 
        // ç§»åŠ¨ç«¯é™ä½å‘å…‰æ¨¡ç³Šåº¦
        shadowBlurBall: isMobile ? 0 : 10,
        shadowBlurEnemy: isMobile ? 10 : 20,
        textScale: isMobile ? 1.5 : 1 // æ–‡å­—å¤§å°ç¼©æ”¾
    };

    let width, height, dpr;

    function resize() {
        // --- å…³é”®ï¼šé«˜æ¸…å±é€‚é… (High DPI Scaling) ---
        dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        
        // è®¾ç½® Canvas å®é™…åƒç´ å¤§å°
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        
        // è®¾ç½® CSS æ ·å¼å¤§å°
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        
        // ç¼©æ”¾ç»˜å›¾ä¸Šä¸‹æ–‡ï¼Œä¹‹åæ‰€æœ‰çš„ç»˜åˆ¶åæ ‡éƒ½å¯ä»¥ç›´æ¥ç”¨ width/heightï¼Œä¸ç”¨æ‰‹åŠ¨ä¹˜ dpr
        ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resize);
    resize();

    // --- éŸ³æ•ˆç³»ç»Ÿ ---
    const AudioEngine = {
        ctx: null,
        isMuted: false,
        init: function() {
            if (!this.ctx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            }
            if (this.ctx.state === 'suspended') this.ctx.resume();
        },
        playHit: function() {
            if (this.isMuted || !this.ctx) return;
            if (Math.random() > 0.5) return;
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.frequency.setValueAtTime(200 + Math.random()*200, t);
            osc.type = 'triangle';
            gain.gain.setValueAtTime(0.02, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(); osc.stop(t + 0.05);
        },
        playExplode: function() {
            if (this.isMuted || !this.ctx) return;
            const t = this.ctx.currentTime;
            const freqs = [880, 1100, 1320];
            const randomPitchOffset = Math.random() * 200;
            freqs.forEach((f, i) => {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(f + randomPitchOffset, t);
                gain.gain.setValueAtTime(0.03, t); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3 + i * 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.5);
            });
        }
    };

    // --- æ¸¸æˆå˜é‡ ---
    let balls = [];
    let enemies = [];
    let particles = [];
    let frame = 0;
    let isRunning = false;
    let killCount = 0;

    // --- ç±»å®šä¹‰ ---

    class Ball {
        constructor(x, y, vx, vy) {
            this.x = x; this.y = y;
            this.vx = vx; this.vy = vy;
            this.radius = 4;
            this.color = '#00d2d3';
        }

        update() {
            // ç§»åŠ¨ç«¯å‡å°‘è‡ªåŠ¨è¿½è¸ªçš„é¢‘ç‡ï¼ŒèŠ‚çœæ€§èƒ½
            if (frame % 5 === 0 && enemies.length > 0) {
                // æç®€ä¼˜åŒ–ï¼šåªå–å‰3ä¸ªæ•Œäººè®¡ç®—è·ç¦»ï¼Œå¤§å¹…å‡å°‘è®¡ç®—é‡
                const checkList = enemies.length > 5 ? enemies.slice(0, 5) : enemies;
                let closest = null;
                let minDist = Infinity;
                
                for(let e of checkList) {
                    const d = (e.x - this.x)**2 + (e.y - this.y)**2;
                    if (d < minDist) { minDist = d; closest = e; }
                }
                
                if (closest) {
                    const angle = Math.atan2(closest.y - this.y, closest.x - this.x);
                    this.vx += Math.cos(angle) * 0.25;
                    this.vy += Math.sin(angle) * 0.25;
                }
            }

            this.x += this.vx;
            this.y += this.vy;
            
            const speed = Math.hypot(this.vx, this.vy);
            if (speed > 13) {
                this.vx = (this.vx / speed) * 13;
                this.vy = (this.vy / speed) * 13;
            } else if (speed < 5) {
                 this.vx = (this.vx / speed) * 5;
                 this.vy = (this.vy / speed) * 5;
            }

            if (this.x < 0 || this.x > width) this.vx *= -1;
            if (this.y < 0 || this.y > height) this.vy *= -1;
            
            this.x = Math.max(0, Math.min(width, this.x));
            this.y = Math.max(0, Math.min(height, this.y));
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();
            // ç§»åŠ¨ç«¯å¦‚æœä¸å¡ï¼Œå¯ä»¥ä¿ç•™çƒçš„å‘å…‰ï¼›å¡é¡¿åˆ™ config.shadowBlurBall ä¸º 0
            if (config.shadowBlurBall > 0 && balls.length < 80) {
                ctx.shadowBlur = config.shadowBlurBall;
                ctx.shadowColor = this.color;
            } else {
                ctx.shadowBlur = 0;
            }
        }
    }

    class Enemy {
        constructor() {
            this.radius = 30 + Math.random() * 20;
            // ç¡®ä¿ç”Ÿæˆåœ¨å±å¹•å†…
            this.x = Math.random() * (width - 60) + 30;
            this.y = Math.random() * (height - 60) + 30;
            
            this.maxHp = 5 + Math.floor(killCount / 4);
            this.hp = this.maxHp;
            
            const hue = (frame * 0.5 + Math.random()*30) % 360;
            this.color = `hsl(${hue}, 80%, 60%)`;
            this.angle = Math.random() * Math.PI;
            this.rotSpeed = (Math.random() - 0.5) * 0.04;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle + frame * this.rotSpeed);
            
            ctx.shadowBlur = config.shadowBlurEnemy; // ç§»åŠ¨ç«¯å‡å¼±å‘å…‰
            ctx.shadowColor = this.color;
            
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const theta = (i / 6) * Math.PI * 2;
                const px = Math.cos(theta) * this.radius;
                const py = Math.sin(theta) * this.radius;
                if (i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.closePath();
            
            ctx.lineWidth = 4;
            ctx.strokeStyle = this.color;
            ctx.stroke();
            
            ctx.fillStyle = this.color;
            ctx.globalAlpha = 0.2;
            ctx.fill();
            ctx.restore();
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.globalCompositeOperation = 'source-over'; 
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // æ ¹æ®é…ç½®ç¼©æ”¾å­—ä½“
            ctx.font = `bold ${20 * config.textScale}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#000000';
            ctx.strokeText(this.hp, this.x, this.y);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(this.hp, this.x, this.y);
            
            ctx.globalCompositeOperation = 'lighter';
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y;
            const a = Math.random() * Math.PI * 2;
            const s = Math.random() * 6;
            this.vx = Math.cos(a) * s;
            this.vy = Math.sin(a) * s;
            this.life = 1.0;
            this.color = color;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.05; // ç²’å­æ¶ˆå¤±å¿«ä¸€ç‚¹ï¼Œçœæ€§èƒ½
        }
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // --- æ¸¸æˆé€»è¾‘ ---

    function initGame() {
        balls = [];
        enemies = [];
        particles = [];
        killCount = 0;
        frame = 0;
        
        balls.push(new Ball(width/2, height/2, 6, -6));
        for(let i=0; i<3; i++) enemies.push(new Enemy());
        
        document.getElementById('overlay').style.display = 'none';
        
        if (!isRunning) {
            isRunning = true;
            loop();
        }
    }

    function checkCollisions() {
        for (let i = balls.length - 1; i >= 0; i--) {
            let b = balls[i];
            
            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                
                const dx = b.x - e.x;
                const dy = b.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < b.radius + e.radius * 0.9) {
                    const angle = Math.atan2(dy, dx);
                    b.vx = Math.cos(angle) * 10; 
                    b.vy = Math.sin(angle) * 10;
                    b.x = e.x + Math.cos(angle) * (e.radius + b.radius + 2);
                    b.y = e.y + Math.sin(angle) * (e.radius + b.radius + 2);
                    
                    e.hp--;
                    e.radius *= 0.98; 
                    AudioEngine.playHit();

                    if (e.hp <= 0) {
                        enemies.splice(j, 1);
                        killCount++;
                        AudioEngine.playExplode();
                        
                        // ç§»åŠ¨ç«¯å‡å°‘ç²’å­æ•°é‡
                        const particleCount = isMobile ? 5 : 8;
                        for(let k=0; k<particleCount; k++) particles.push(new Particle(e.x, e.y, e.color));
                        
                        if (balls.length < config.maxBalls) {
                            let newBall = new Ball(b.x, b.y, -b.vx, -b.vy);
                            newBall.color = e.color; 
                            balls.push(newBall);
                        }
                    }
                    break; 
                }
            }
        }
    }

    function spawnLogic() {
        // ç§»åŠ¨ç«¯é™ä½æ•Œäººç”Ÿæˆä¸Šé™
        const maxEnemies = isMobile ? 8 : 12;
        if (enemies.length < 4 || (frame % config.spawnRate === 0 && enemies.length < maxEnemies)) {
            let e = new Enemy();
            let overlap = false;
            for(let other of enemies) {
                const d = Math.hypot(e.x - other.x, e.y - other.y);
                if (d < e.radius + other.radius + 50) overlap = true;
            }
            for(let b of balls) {
                const d = Math.hypot(e.x - b.x, e.y - b.y);
                if (d < e.radius + 80) overlap = true;
            }
            if (!overlap) enemies.push(e);
        }
    }

    function updateUI() {
        document.getElementById('ball-count').innerText = balls.length;
        document.getElementById('kill-count').innerText = killCount;
    }

    function resetGame() {
        AudioEngine.init();
        initGame();
    }
    
    function toggleMute() {
        AudioEngine.isMuted = !AudioEngine.isMuted;
        const btn = document.getElementById('mute-btn');
        btn.innerText = AudioEngine.isMuted ? "ğŸ”Š éŸ³æ•ˆ: å…³" : "ğŸ”Š éŸ³æ•ˆ: å¼€";
        btn.style.opacity = AudioEngine.isMuted ? "0.5" : "1";
    }

    function toggleRules() {
        const modal = document.getElementById('rules-modal');
        modal.style.display = modal.style.display === 'block' ? 'none' : 'block';
    }

    // ç»‘å®šç‚¹å‡»å’Œè§¦æ‘¸äº‹ä»¶ï¼Œä¿è¯ç§»åŠ¨ç«¯å“åº”å¿«
    document.getElementById('start-btn').addEventListener('click', () => {
        AudioEngine.init();
        initGame();
    });
    
    // é˜»æ­¢Canvasé»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼Œé˜²æ­¢åŒå‡»æ”¾å¤§ç­‰
    canvas.addEventListener('touchstart', (e) => e.preventDefault(), {passive: false});

    function loop() {
        if (!isRunning) return;
        frame++;

        ctx.globalCompositeOperation = 'source-over';
        // ç§»åŠ¨ç«¯æ‹–å°¾æ·¡ä¸€ç‚¹ï¼Œå‡å°‘é‡ç»˜æ—¶çš„è„åƒç´ æ„Ÿ
        ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; 
        ctx.fillRect(0, 0, width, height);

        ctx.globalCompositeOperation = 'lighter';

        spawnLogic();
        balls.forEach(b => { b.update(); b.draw(); });
        
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.update();
            p.draw();
            if (p.life <= 0) particles.splice(i, 1);
        }

        enemies.forEach(e => e.draw());
        ctx.globalCompositeOperation = 'lighter';

        checkCollisions();
        updateUI();

        requestAnimationFrame(loop);
    }
</script>
</body>
</html>
